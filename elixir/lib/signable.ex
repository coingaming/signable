defmodule Signable do
  @moduledoc "Protobuf deterministic serialization module"

  @type ec_private_key ::
          {:ECPrivateKey, non_neg_integer(), binary(), {:namedCurve, tuple()}, binary() | nil}

  @type ec_public_key :: {{:ECPoint, binary()}, {:namedCurve, tuple()}}

  @doc """
    Generate a ECDSA signature using SHA256 hash of provided payload.
    Key and curve must be provided in erlang :crypto format
    (binary private key and atom curve specifier, e.g. :secp256r1)

    Returns DER(binary) representation of the signature

    ## Examples

      iex> {public, private} = :crypto.generate_key(:ecdh, :secp256r1)
      iex> Signable.sign("secret message", private, :secp256r1)
  """
  @spec sign(payload :: binary(), private_key :: binary(), curve :: atom()) :: binary()
  def sign(payload, private_key, curve) do
    key =
      {:ECPrivateKey, 1, private_key, {:namedCurve, :pubkey_cert_records.namedCurves(curve)}, nil}

    sign(payload, key)
  end

  @doc """
    Generate a ECDSA signature using SHA256 hash of provided payload.
    Key and curve must be provided in DER(binary) or ASN1Type format

    Returns DER(binary) representation of the signature

    ## Examples

      iex> {public, private} = :crypto.generate_key(:ecdh, :secp256r1)
      iex> ec_key = {:ECPrivateKey, 1, private, {:namedCurve, :pubkey_cert_records.namedCurves(:secp256r1)}, public}
      iex> Signable.sign("secret message", ec_key)
      iex> der_key = :public_key.der_encode(:ECPrivateKey, ec_key)
      iex> Signable.sign("secret message", der_key)

  """
  @spec sign(
          payload :: binary(),
          private_key ::
            binary() | ec_private_key()
        ) :: binary()
  def sign(payload, private_key) when is_binary(private_key) do
    key = :public_key.der_decode(:ECPrivateKey, private_key)
    sign(payload, key)
  end

  def sign(payload, {:ECPrivateKey, _, _, _, _} = private_key) do
    :public_key.sign(payload, :sha256, private_key)
  end

  @doc """
    Verify a ECDSA signature generated by signing a SHA256 hash of provided payload.
    Key and curve must be provided in erlang :crypto format (binary public key and curve specifier, e.g. :secp256r1)

    Returns true if signature is valid, false otherwise

    ## Examples

      iex> {public, private} = :crypto.generate_key(:ecdh, :secp256r1)
      iex> payload = "secret message"
      iex> signature = Signable.sign(payload, private, :secp256r1)
      iex> Signable.verify_signature(payload, signature, public, :secp256r1)
      true
  """
  @spec verify_signature(
          payload :: binary(),
          signature :: binary(),
          public_key :: binary(),
          curve :: atom()
        ) :: bool()
  def verify_signature(payload, signature, public_key, curve) do
    ec_pubkey = {{:ECPoint, public_key}, {:namedCurve, :pubkey_cert_records.namedCurves(curve)}}
    verify_signature(payload, signature, ec_pubkey)
  end

  @doc """
    Verify a ECDSA signature generated by signing a SHA256 hash of provided payload.
    Key and curve must be provided in DER(binary) or ASN1Type format

    Returns true if signature is valid, false otherwise

    ## Examples

      iex> {public, private} = :crypto.generate_key(:ecdh, :secp256r1)
      iex> payload = "secret message"
      iex> signature = Signable.sign(payload, private, :secp256r1)
      iex> ec_key = {{:ECPoint, public}, {:namedCurve, :pubkey_cert_records.namedCurves(:secp256r1)}}
      iex> Signable.verify_signature(payload, signature, ec_key)
      true
  """
  @spec verify_signature(
          payload :: binary(),
          signature :: binary(),
          public_key :: binary() | ec_public_key()
        ) :: boolean()
  def verify_signature(payload, signature, public_key) when is_binary(public_key) do
    verify_signature(payload, signature, der_pk_to_ec_pubkey(public_key))
  end

  def verify_signature(payload, signature, {{:ECPoint, _}, {_, _}} = public_key) do
    :public_key.verify(payload, :sha256, signature, public_key)
  end

  @doc """
    Deterministically serialize a protobuf message according to a specified set of encoding rules
  """
  @spec serialize(message :: struct()) :: binary()
  def serialize(message) when is_struct(message) do
    message_mod = message.__struct__
    serialize(message_mod, message)
  end

  @spec serialize(message_mod :: atom(), message :: struct()) :: binary()
  defp serialize(message_mod, message) do
    %Protobuf.MessageProps{field_props: props, oneof: oneof_list} =
      message_mod.__message_props__()

    ## oneof_list is a keyword name_atom -> index, but we need a reverse to lookup
    oneof_map =
      oneof_list
      |> Enum.reduce(%{}, fn {k, v}, acc -> Map.put(acc, v, k) end)

    props
    |> Enum.sort(fn {index1, _}, {index2, _} -> index1 <= index2 end)
    |> Enum.reduce(<<>>, &(&2 <> prop_handler(&1, message, oneof_map)))
  end

  @spec prop_handler(
          {index :: non_neg_integer(), prop :: Protobuf.FieldProps.t()},
          message :: struct() | integer() | binary() | bool(),
          oneof_map :: %{atom() => non_neg_integer()}
        ) :: binary()
  defp prop_handler({index, prop}, message, oneof_map) when is_map(message) do
    %Protobuf.FieldProps{
      oneof: oneof_index,
      name_atom: name_atom
    } = prop

    prop_val = Map.get(message, name_atom)

    serialize_index(index) <>
      if not is_nil(oneof_index) do
        oneof_key = Map.fetch!(oneof_map, oneof_index)
        oneof_val = Map.fetch!(message, oneof_key)

        cond do
          !is_nil(oneof_val) and elem(oneof_val, 0) == name_atom ->
            serialize_one_property(prop, elem(oneof_val, 1))

          !is_nil(oneof_val) ->
            <<>>

          true ->
            serialize_one_property(prop, oneof_val)
        end
      else
        serialize_one_property(prop, prop_val)
      end
  end

  defp prop_handler({index, prop}, message, _oneof_map) do
    serialize_index(index) <> serialize_one_property(prop, message)
  end

  @spec serialize_one_property(prop :: Protobuf.FieldProps.t(), message :: any()) :: binary()
  defp serialize_one_property(prop, message) when is_list(message) do
    Enum.reduce(message, <<>>, &(&2 <> serialize_one_property(prop, &1)))
  end

  defp serialize_one_property(prop, message) do
    %Protobuf.FieldProps{
      type: type,
      embedded?: embedded?,
      enum?: enum?
    } = prop

    cond do
      enum? ->
        {:enum, enum_type} = type
        serialize_enum(enum_type, message)

      embedded? ->
        if is_nil(message) do
          <<>>
        else
          serialize(type, message)
        end

      true ->
        serialize_scalar(type, message)
    end
  end

  @spec serialize_index(index :: non_neg_integer()) :: binary()
  defp serialize_index(index) do
    serialize_scalar(:uint32, index)
  end

  @spec serialize_enum(enum :: atom(), value :: atom()) :: binary()
  defp serialize_enum(enum, value) do
    index = enum.mapping() |> Map.get(value)
    serialize_scalar(:uint32, index)
  end

  @spec serialize_scalar(type :: atom(), value :: integer() | String.t() | boolean() | nil) ::
          binary()
  defp serialize_scalar(type, nil) do
    serialize_scalar(type, Protobuf.Builder.type_default(type))
  end

  defp serialize_scalar(type, value) when type == :uint32 or type == :int32 do
    <<value::32>>
  end

  defp serialize_scalar(type, value) when type == :uint64 or type == :int64 do
    <<value::64>>
  end

  defp serialize_scalar(type, value) when type == :string or type == :bytes do
    value
  end

  defp serialize_scalar(:bool, value) do
    if value do
      <<1::8>>
    else
      <<0::8>>
    end
  end

  @spec der_pk_to_ec_pubkey(der_pk :: binary()) :: ec_public_key()
  def der_pk_to_ec_pubkey(der_pk) do
    {:SubjectPublicKeyInfo, {:AlgorithmIdentifier, _, ec_params}, pubkey} =
      :public_key.der_decode(:SubjectPublicKeyInfo, der_pk)

    namedCurve = :public_key.der_decode(:EcpkParameters, ec_params)
    {{:ECPoint, pubkey}, namedCurve}
  end
end
