defmodule Signable do
  @moduledoc "Protobuf deterministic serialization module"

  alias HmCrypto.EcUtils

  require EcUtils.ECPrivateKey, as: ECPrivateKey
  require EcUtils.ECPoint, as: ECPoint

  @doc """
    Generate a ECDSA signature using SHA256 hash of provided payload.
    Key and curve must be provided in erlang :crypto format
    (binary private key and atom curve specifier, e.g. :secp256r1)

    Returns DER(binary) representation of the signature

    ## Examples

      iex> {_public, private} = :crypto.generate_key(:ecdh, :secp256r1)
      iex> Signable.sign("secret message", private, :secp256r1)
  """
  @spec sign(payload :: binary(), private_key :: binary(), curve :: atom()) :: binary()
  def sign(payload, private_key, curve) do
    sign(payload, EcUtils.crypto_secret_to_ec_private_key(private_key, curve))
  end

  @doc """
    Generate a ECDSA signature using SHA256 hash of provided payload.
    Key and curve must be provided in DER(binary) or ASN1Type format

    Returns DER(binary) representation of the signature

    ## Examples

      iex> {public, private} = :crypto.generate_key(:ecdh, :secp256r1)
      iex> ec_key = HmCrypto.EcUtils.crypto_secret_to_ec_private_key(private, :secp256r1, public)
      iex> Signable.sign("secret message", ec_key)
      iex> der_key = :public_key.der_encode(:ECPrivateKey, ec_key)
      iex> Signable.sign("secret message", der_key)

  """
  @spec sign(
          payload :: binary(),
          private_key ::
            binary() | ECPrivateKey.t()
        ) :: binary()
  def sign(payload, private_key) when is_binary(private_key) do
    key = :public_key.der_decode(:ECPrivateKey, private_key)
    sign(payload, key)
  end

  def sign(payload, ECPrivateKey.record() = private_key) do
    :public_key.sign(payload, :sha256, private_key)
  end

  @doc """
    Verify a ECDSA signature generated by signing a SHA256 hash of provided payload.
    Key and curve must be provided in erlang :crypto format (binary public key and curve specifier, e.g. :secp256r1)

    Returns true if signature is valid, false otherwise

    ## Examples

      iex> {public, private} = :crypto.generate_key(:ecdh, :secp256r1)
      iex> payload = "secret message"
      iex> signature = Signable.sign(payload, private, :secp256r1)
      iex> Signable.verify_signature(payload, signature, public, :secp256r1)
      true
  """
  @spec verify_signature(
          payload :: binary(),
          signature :: binary(),
          public_key :: binary(),
          curve :: atom()
        ) :: bool()
  def verify_signature(payload, signature, public_key, curve) do
    ec_pubkey =
      EcUtils.crypto_pubkey_to_der(public_key, curve) |> EcUtils.der_pubkey_to_ec_point()

    verify_signature(payload, signature, ec_pubkey)
  end

  @doc """
    Verify a ECDSA signature generated by signing a SHA256 hash of provided payload.
    Key and curve must be provided in DER(binary) or ASN1Type format

    Returns true if signature is valid, false otherwise

    ## Examples

      iex> {public, private} = :crypto.generate_key(:ecdh, :secp256r1)
      iex> payload = "secret message"
      iex> signature = Signable.sign(payload, private, :secp256r1)
      iex> ec_key = HmCrypto.EcUtils.crypto_pubkey_to_der(public, :secp256r1) |> HmCrypto.EcUtils.der_pubkey_to_ec_point()
      iex> Signable.verify_signature(payload, signature, ec_key)
      true
  """
  @spec verify_signature(
          payload :: binary(),
          signature :: binary(),
          public_key :: binary() | EcUtils.ec_point()
        ) :: boolean()
  def verify_signature(payload, signature, public_key) when is_binary(public_key) do
    verify_signature(payload, signature, EcUtils.der_pubkey_to_ec_point(public_key))
  end

  def verify_signature(payload, signature, {ECPoint.record(), {_, _}} = public_key) do
    :public_key.verify(payload, :sha256, signature, public_key)
  end

  @doc """
    Deterministically serialize a protobuf message according to a specified set of encoding rules
  """
  @spec serialize(message :: struct()) :: binary()
  def serialize(message) when is_struct(message) do
    message_mod = message.__struct__
    serialize(message_mod, message)
  end

  @spec serialize(message_mod :: atom(), message :: struct()) :: binary()
  defp serialize(message_mod, message) do
    %Protobuf.MessageProps{field_props: props, oneof: oneof_list} =
      message_mod.__message_props__()

    message =
      message
      |> Protobuf.Encodable.to_protobuf(message_mod)

    ## oneof_list is a keyword name_atom -> index, but we need a reverse to lookup
    oneof_map =
      oneof_list
      |> Enum.reduce(%{}, fn {k, v}, acc -> Map.put(acc, v, k) end)

    props
    |> Enum.sort(fn {index1, _}, {index2, _} -> index1 <= index2 end)
    |> Enum.reduce(<<>>, &(&2 <> prop_handler(&1, message, oneof_map)))
  end

  @spec prop_handler(
          {index :: non_neg_integer(), prop :: Protobuf.FieldProps.t()},
          message :: struct() | integer() | binary() | bool(),
          oneof_map :: %{atom() => non_neg_integer()}
        ) :: binary()
  defp prop_handler({index, prop}, message, oneof_map) when is_map(message) do
    %Protobuf.FieldProps{
      oneof: oneof_index,
      name_atom: name_atom
    } = prop

    prop_val = Map.get(message, name_atom)

    if is_nil(oneof_index) do
      cond do
        is_nil(prop_val) ->
          <<>>

        true ->
          index
          |> serialize_index()
          |> safe_concat(serialize_one_property(prop, prop_val))
      end
    else
      oneof_key = Map.fetch!(oneof_map, oneof_index)
      oneof_val = Map.fetch!(message, oneof_key)

      if !is_nil(oneof_val) and elem(oneof_val, 0) == name_atom do
        index
        |> serialize_index()
        |> safe_concat(serialize_one_property(prop, elem(oneof_val, 1)))
      else
        <<>>
      end
    end
  end

  defp prop_handler({index, prop}, message, _oneof_map) do
    index
    |> serialize_index()
    |> safe_concat(serialize_one_property(prop, message))
  end

  @spec serialize_one_property(prop :: Protobuf.FieldProps.t(), message :: any()) ::
          binary() | nil
  defp serialize_one_property(prop, message) when is_list(message) do
    case message do
      [] -> nil
      message -> Enum.reduce(message, <<>>, &safe_concat(&2, serialize_one_property(prop, &1)))
    end
  end

  defp serialize_one_property(prop, message) do
    %Protobuf.FieldProps{
      type: type,
      embedded?: embedded?,
      enum?: enum?
    } = prop

    cond do
      enum? ->
        {:enum, enum_type} = type
        serialize_enum(enum_type, message)

      embedded? ->
        if is_nil(message) do
          nil
        else
          serialize(type, message)
        end

      true ->
        serialize_scalar(type, message)
    end
  end

  @spec serialize_index(index :: non_neg_integer()) :: binary()
  defp serialize_index(index) do
    serialize_scalar(:uint32, index)
  end

  @spec serialize_enum(enum :: atom(), value :: atom()) :: binary()
  defp serialize_enum(enum, value) do
    index = enum.mapping() |> Map.get(value, value)
    serialize_scalar(:uint32, index)
  end

  @spec serialize_scalar(type :: atom(), value :: integer() | String.t() | boolean() | nil) ::
          binary()
  defp serialize_scalar(type, nil) do
    serialize_scalar(type, Protobuf.Builder.type_default(type))
  end

  defp serialize_scalar(type, value) when type == :uint32 or type == :int32 do
    <<value::32>>
  end

  defp serialize_scalar(type, value) when type == :uint64 or type == :int64 do
    <<value::64>>
  end

  defp serialize_scalar(type, value) when type == :string or type == :bytes do
    value
  end

  defp serialize_scalar(:bool, value) do
    if value do
      <<1::8>>
    else
      <<0::8>>
    end
  end

  defp safe_concat(left, right) when is_nil(left) or is_nil(right) do
    <<>>
  end

  defp safe_concat(left, right) do
    left <> right
  end
end
